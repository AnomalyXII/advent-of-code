package net.anomalyxii.aoc.aoc2022;

import net.anomalyxii.aoc.context.SolutionContext;
import net.anomalyxii.aoc.utils.geometry.Grid;
import net.anomalyxii.aoc.utils.ocr.LetterSet;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

class Day10Test {

    private static final SolutionContext EXAMPLE = SolutionContext.builder()
            .example(2022, 10)
            .withLetterSet(new NotRealLetterSet())
            .build();
    private static final SolutionContext LIVE = SolutionContext.live(2022, 10);

    // ****************************************
    // Test Methods
    // ****************************************

    // calculateAnswerForPart1

    @Test
    void calculateAnswerForPart1_Example() {
        // arrange
        final Day10 challenge = new Day10();

        // act
        final long answer = challenge.calculateAnswerForPart1(EXAMPLE);

        // assert
        assertThat(answer)
                .isEqualTo(13140L);
    }

    @Test
    void calculateAnswerForPart1_Live() {
        // arrange
        final Day10 challenge = new Day10();

        // act
        final long answer = challenge.calculateAnswerForPart1(LIVE);

        // assert
        assertThat(answer)
                .isEqualTo(14820L);
    }

    // calculateAnswerForPart2

    @Test
    void calculateAnswerForPart2_Example() {
        // arrange
        final Day10 challenge = new Day10();

        // act
        final String answer = challenge.calculateAnswerForPart2(EXAMPLE);

        // assert
        assertThat(answer)
                .isEqualTo("abcdefgh");
    }

    @Test
    void calculateAnswerForPart2_Live() {
        // arrange
        final Day10 challenge = new Day10();

        // act
        final String answer = challenge.calculateAnswerForPart2(LIVE);

        // assert
        assertThat(answer)
                .isEqualTo("RZEKEFHA");
    }

    // ****************************************
    // Private Helper Classes
    // ****************************************

    /*
     * A `LetterSet` to match the nonsense generated by Part II...
     */
    private static final class NotRealLetterSet implements LetterSet {

        /*
         * Pure nonsense, as is spat out by the Part II example.
         */
        private static final int[][][] NONSENSE = new int[][][]{
                new int[][]{
                        new int[]{1, 1, 0, 0, 1}, // ##..#
                        new int[]{1, 1, 1, 0, 0}, // ###..
                        new int[]{1, 1, 1, 1, 0}, // ####.
                        new int[]{1, 1, 1, 1, 1}, // #####
                        new int[]{1, 1, 1, 1, 1}, // #####
                        new int[]{1, 1, 1, 1, 1}, // #####
                },
                new int[][]{
                        new int[]{1, 0, 0, 1, 1}, // #..##
                        new int[]{0, 1, 1, 1, 0}, // .###.
                        new int[]{0, 0, 0, 1, 1}, // ...##
                        new int[]{0, 0, 0, 0, 0}, // .....
                        new int[]{1, 0, 0, 0, 0}, // #....
                        new int[]{1, 1, 0, 0, 0}, // ##...
                },
                new int[][]{
                        new int[]{0, 0, 1, 1, 0}, // ..##.
                        new int[]{0, 0, 1, 1, 1}, // ..###
                        new int[]{1, 1, 0, 0, 0}, // ##...
                        new int[]{1, 1, 1, 1, 1}, // #####
                        new int[]{0, 0, 1, 1, 1}, // ..###
                        new int[]{0, 0, 0, 0, 1}, // ....#
                },
                new int[][]{
                        new int[]{0, 1, 1, 0, 0}, // .##..
                        new int[]{0, 0, 0, 1, 1}, // ...##
                        new int[]{0, 1, 1, 1, 1}, // .####
                        new int[]{0, 0, 0, 0, 0}, // .....
                        new int[]{1, 1, 1, 0, 0}, // ###..
                        new int[]{1, 1, 1, 1, 1}, // #####
                },
                new int[][]{
                        new int[]{1, 1, 0, 0, 1}, // ##..#
                        new int[]{1, 0, 0, 0, 1}, // #...#
                        new int[]{0, 0, 0, 0, 1}, // ....#
                        new int[]{1, 1, 1, 1, 1}, // #####
                        new int[]{0, 0, 0, 0, 1}, // ....#
                        new int[]{1, 0, 0, 0, 0}, // #....
                },
                new int[][]{
                        new int[]{1, 0, 0, 1, 1}, // #..##
                        new int[]{1, 1, 0, 0, 0}, // ##...
                        new int[]{1, 1, 1, 0, 0}, // ###..
                        new int[]{0, 0, 0, 0, 0}, // .....
                        new int[]{1, 1, 1, 1, 1}, // #####
                        new int[]{0, 0, 0, 1, 1}, // ...##
                },
                new int[][]{
                        new int[]{0, 0, 1, 1, 0}, // ..##.
                        new int[]{1, 1, 1, 0, 0}, // ###..
                        new int[]{0, 0, 1, 1, 1}, // ..###
                        new int[]{1, 1, 1, 1, 1}, // #####
                        new int[]{0, 0, 0, 0, 0}, // .....
                        new int[]{1, 1, 1, 1, 1}, // #####
                },
                new int[][]{
                        new int[]{0, 1, 1, 0, 0}, // .##..
                        new int[]{0, 1, 1, 1, 0}, // .###.
                        new int[]{1, 0, 0, 0, 0}, // #....
                        new int[]{0, 0, 0, 0, 0}, // .....
                        new int[]{0, 1, 1, 1, 1}, // .####
                        new int[]{0, 0, 0, 0, 0}, // .....
                },
        };

        // LetterSet Methods

        @Override
        public char match(final Grid grid) {
            for (int i = 0; i < NONSENSE.length; i++)
                if (grid.matches(NONSENSE[i]))
                    return (char) ('a' + i);

            throw new IllegalStateException("Failed to match ... whatever is nonsense is.");
        }
    }
}

